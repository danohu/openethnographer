<?php
/**
 * Implements hook_permission().
 */
function annotation_permission() {
  return array(
    'administer annotation types' => array(
      'title' => t('Administer annotation types'),
      'description' => t('Allows users to administer annotation types.'),
      'restrict access' => TRUE,
    ),
    'administer annotations' => array(
      'title' => t('Administer annotations'),
      'description' => t('Allows users to administer annotations.'),
      'restrict access' => TRUE,
    ),
    'create annotations' => array(
      'title' => t('Create annotations'),
      'description' => t('Allows users to annotation tasks.'),
      'restrict access' => TRUE,
    ),
    'view annotations' => array(
      'title' => t('View annotations'),
      'description' => t('Allows users to view annotations.'),
      'restrict access' => TRUE,
    ),
    'edit any annotations' => array(
      'title' => t('Edit any annotations'),
      'description' => t('Allows users to edit any annotations.'),
      'restrict access' => TRUE,
    ),
    'edit own annotations' => array(
      'title' => t('Edit own annotation'),
      'description' => t('Allows users to edit own annotations.'),
      'restrict access' => TRUE,
    ),
  );
}


/**
 * Implements hook_entity_info().
 */
function annotation_entity_info() {
  $info = array(
    'annotation' => array(
      'label' => t('Annotation'),
      'plural label' => t('Annotations'),
      'description' => t('An entity type used by the Annotator.'),
      //'entity class' => 'AnnotationClassRevision',
      'controller class' => 'AnnotationAPIController',
      'views controller class' => 'EntityDefaultViewsController',
      'base table' => 'annotation',
      // 'revision table' => 'annotation_revision',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'id',
        'bundle' => 'type',
        'language' => 'language',
        // 'revision' => 'revision_id',
      ),
      'label callback' => 'annotation_label',
      'uri callback' => 'annotation_uri',
      'bundles' => array(
        'annotator' => array(
          'label' => 'Annotator',
          'description' => 'Default Annotation type, use Annotator (need install).',
          'admin' => array(
            'path' => 'admin/structure/annotation/manage/%annotation_type',
            'real path' => 'admin/structure/annotation/manage/annotator',
            'bundle argument' => 4,
            'access arguments' => array('administer annotation'),
          ),
          'custom' => FALSE,
          'plugin' => 'annotator',
        )
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Default'),
          'custom settings' => FALSE,
        ),
      ),
      'module' => 'annotation',
      'static cache' => TRUE,
    ),
  );

  // Support entity cache module.
  if (module_exists('entitycache')) {
    $info['annotation']['field cache'] = FALSE;
    $info['annotation']['entity cache'] = TRUE;
  }

  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function annotation_entity_property_info_alter(&$info) {
  $properties = &$info['annotation']['properties'];
  $properties['created'] = array(
    'label' => t('Date created'),
    'type' => 'date',
    'description' => t('The date the annotation was created.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer annotations',
    'schema field' => 'created',
  );
  $properties['updated'] = array(
    'label' => t('Date updated'),
    'type' => 'date',
    'schema field' => 'updated',
    'description' => t('The date the annotation was last updated.'),
  );
  $properties['user'] = array(
    'label' => t('Author'),
    'type' => 'user',
    'description' => t('The author of the annotation.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer annotations',
    'required' => TRUE,
    'schema field' => 'uid',
  );
}

/**
 * Implements hook_menu().
 */
function annotation_menu() {
  $items = array();
  $items['admin/content/annotation'] = array(
    'title' => 'Annotations',
    'description' => 'Manage Annotations',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('annotation_admin_content'),
    'access arguments' => array('access content overview'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'annotation.admin.inc',
  );
  $items['admin/content/annotation/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/annotation'] = array(
    'title' => 'Annotation',
    'description' => 'Manage annotaions.',
    'page callback' => 'annotation_admin_types',
    'access arguments' => array('administer content types'),
    'file' => 'annotation.admin.inc',
  );
  $items['admin/structure/annotation/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  /*
  $items['admin/structure/annotation/add'] = array(
    'title' => 'Add annotation type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('annotation_type_form'),
    'access arguments' => array('administer content types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'annotation.admin.inc',
  );
  */
  $entity_info = entity_get_info('annotation');
  foreach ($entity_info['bundles'] as $annotation_type => $bundle_info) {
    if (isset($bundle_info['admin'])) {
      // Get the base path and access.
      $path = $bundle_info['admin']['path'];
      $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
      $access += array(
        'access callback' => 'user_access',
        'access arguments' => array('administer annotations'),
      );

      // The annotation type must be passed to the page callbacks. It might be
      // configured as a wildcard (multiple annotation types sharing the same menu
      // router path).
      $annotation_type_argument = isset($bundle_info['admin']['bundle argument']) ? $bundle_info['admin']['bundle argument'] : $annotation_type;
      $items[$path] = array(
        'title' => 'Edit annotation type',
        //'title callback' => 'annotation_type_get_name',
        //'title arguments' => array(4),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('annotation_type_form', $annotation_type_argument),
        'file' => 'annotation.admin.inc',
      ) + $access;

      // Add the 'annotation type settings' tab.
      $items["$path/edit"] = array(
        'title' => 'Edit',
        'type' => MENU_DEFAULT_LOCAL_TASK,
      );
    }
  }
  $items['annotation/%entity_object'] = array(
    'load arguments' => array('annotation'),
    'title callback' => 'entity_label',
    'title arguments' => array('annotation', 1),
    'page callback' => 'annotation_view_page',
    'page arguments' => array(1, 'annotation'),
    'access callback' => 'annotation_access',
    'access arguments' => array('view', 1),
    'file' => 'annotation.pages.inc',
  );
  $items['annotation/%entity_object/delete'] = array(
    'load arguments' => array('annotation'),
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments'  => array('annotation_delete_form', 1),
    'access callback' => 'annotation_access',
    'access arguments' => array('delete', 1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'annotation.pages.inc',
  );

  // Index; API endpoint
  $items['annotation/api'] = array(
    'page callback' => 'annotation_api',
    'access callback' => /*'annotation_method_access'*/TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );
  // Create; API endpoint to create annotations
  $items['annotation/api/annotations'] = array(
    'page callback' => 'annotation_api_endpoint',
    'access callback' => /*'annotation_method_access'*/TRUE,
    'access arguments' => array('', 'annotation', NULL),
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );
  $items['annotation/api/annotations/%'] = array(
    'page callback' => 'annotation_api_endpoint',
    'page arguments' => array(3),
    'access callback' => /*'annotation_method_access'*/TRUE,
    'access arguments' => array('', 'annotation', 3),
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );
  $items['annotation/api/search'] = array(
    'page callback' => 'annotation_api_search',
//    'access callback' => 'annotation_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );

  $items['annotation/export/%'] = array(
    'title' => 'Export annotations in CATMA format',
    'page callback' => 'annotation_export_catma',
    'page arguments' => array(2),
    'access arguments' => array('access simple page'),
  );


  return $items;
}

/**
 * Access callback.
 */
function annotation_access($op, $entity, $account = NULL, $entity_type = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  if ($account->uid == 1) {
    return TRUE;
  }

  switch ($op) {
    case 'create':
      return user_access('administer annotations', $account)
          || user_access('create annotations', $account);
    case 'view':
      return user_access('administer annotations', $account)
          || user_access('view annotations', $account)
          || ($entity->uid == $account->uid);
    case 'edit':
      return user_access('administer annotations', $account)
          || user_access('edit any annotations', $account)
          || (user_access('edit own annotations', $account) && ($entity->uid == $account->uid));
    case 'delete':
      return user_access('administer annotations', $account)
          || user_access('edit any annotations', $account)
          || (user_access('edit own annotations', $account) && ($entity->uid == $account->uid));
  }
}

/**
 * Method dependent access callback
 * @see annotation_api_endpoint()
 */
function annotation_entity_method_access($op, $entity_type, $entity = NULL, $account = NULL) {
  $method = $_SERVER['REQUEST_METHOD'];

  switch ($method) {
    case 'GET':
      if (isset($entity) && is_numeric($id)) {
        annotation_api_read($id);
        // entity_access('view', $entity_type, $entity = NULL, $account = NULL);
      }
      else {
        annotation_api_index();
        // entity_access('view', $entity_type, $entity = NULL, $account = NULL);
      }
      break;
    case 'POST':
      annotation_api_create();
      // entity_access('create', $entity_type, $entity = NULL, $account = NULL);
      break;
    case 'PUT':
      annotation_api_update($id);
      break;
    case 'DELETE':
      annotation_api_destroy($id);
      break;
  }
}

/**
 * Menu argument loader: loads a annotation type by string.
 *
 * @param $name
 *   The machine-readable name of a node type to load, where '_' is replaced
 *   with '-'.
 *
 * @return
 *   A node type object or FALSE if $name does not exist.
 */
function annotation_type_load($name) {
  $annotation_entity = entity_get_info('annotation');
  $bundle = $annotation_entity['bundles'][$name];
  $bundle['type'] = $name;
  //$type = ctools_export_crud_load('file_type', $name);
  return (object)$bundle;
}

function annotation_type_get_names() {
  $names = &drupal_static(__FUNCTION__);

  if (!isset($names)) {
    $info = entity_get_info('annotation');
    foreach ($info['bundles'] as $bundle => $bundle_info) {
      $names[$bundle] = $bundle_info['label'];
    }
  }

  return $names;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function annotation_ctools_plugin_directory($module, $plugin) {
  if ($module == 'annotator') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function annotation_ctools_plugin_type() {
  return array(
    'annotator' => array(
      'cache' => FALSE,
    ),
  );
}



function id_for_annotation($annotation){
    /* CATMA needs a unique ID for each annotation
     their format is CATMA_31faf252-926d-4d2a-b612-f581dd8362dd
     but we should be OK with OPENETHNOGRAPHER_ANN_id
     we add _ANN because CATMA seems to use the same namespace for 
     Broken out so we can change this if we ever implement
     pseudorandom annotation identifiers
    */
    return "#OPENETHNOGRAPHER_ANN_" . $annotation['id'];
}

function annotations_for_node($nid){
    $nodeurl = $GLOBALS['base_url'] . url("node/$nid");
    $anns = db_query("select id, type, language, created, updated, text, quote, ranges, uid, nid from {annotation} where uri = :uri", array(':uri' => $nodeurl));
    return($anns);
}

function generate_filename($node){
    return "openethnographer_" . $node->nid . ".txt";
}

function range_statement($annot, $node){
    // XXX this may need reorg to cope with >1 range per row
    // for now, we just take the first range
    // also, we ignore the xpath component of it all
    $range = unserialize($annot["ranges"])[0];
    return "( /.{$range['startOffset']}, /.{$range['endOffset']})";
}

function annotation_export_catma($nid){ 
    watchdog('annotation', 'starting');

    $output_format = isset($_GET['format']) ? $_GET['format'] : 'xml';
    $output_format = strtolower($output_format);
    // XXX needs protection against bogus values

    $node = node_load($nid);
    if($node === FALSE) drupal_not_found();
    // XXX add permissions checks here

    $tei = new SimpleXMLElement( <<<XMLTEXT
﻿<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:lang="en" xmlns="http://www.tei-c.org/ns/1.0"></TEI>
XMLTEXT
    );
    $header = $tei->addChild('teiHeader');
    $fileDesc = $header->addChild('fileDesc');
    $fileDesc->addChild('title', $node->title);
    $fileDesc->addChild('author', $node->name);
    $lang = $header->addChild('profileDesc')->addChild('langUsage')->addChild('language', 'english');
    $lang->addAttribute('ident', 'en');    

    $ann_body = $tei->addChild('body')->addChild('ab');

    $filename_content = generate_filename($node);
    $filename_structure = basename($filename_content, '.txt') . '_structure.xml';
    $filename_zip = basename($filename_content, '.txt') . '.zip';

    // get all ecomma ranges for the commons
    $annotations = annotations_for_node($nid);
    if($annotations){
        while ($annot = $annotations->fetchAssoc()){
            $seg = $ann_body->addChild('seg');
            // XXX not clear quite what is the structure of these annotation IDs
            $seg->addAttribute("ana", id_for_annotation($annot));
            $ptr = $seg->addChild("ptr");
            $ptr->addAttribute("type", "inclusion");
            $ptr->addAttribute("target", $filename_content . "#range" . range_statement($annot, $node));
            watchdog("annotation", $annot['ranges']);
        }
    }
    if($output_format == 'zip'){
        $zipfn = tempnam('/tmp', 'openethnographer_'); // XXX abstract out the prefix
        $zip = new ZipArchive;
        $res = $zip->open($zipfn, ZipArchive::CREATE); // XXX ideally, handle failure to open here
        $rawtext = field_get_items('node', $node, 'body')[0]['value']; // XXX this needs to depend on what piece of content is actually in use
        dpm($rawtext);
        $zip->addFromString($filename_content, $rawtext);
        $zip->addFromString($filename_structure, $tei->asXML());
        $zip->close();
        drupal_add_http_header('Content-Type', 'application/zip');
        drupal_add_http_header('Content-disposition', "attachment; filename=$filename_zip");
        readfile($zipfn);
        drupal_exit();
    }
    else{ // XXX do we need xml-only output? maybe just for debugging?
        drupal_add_http_header('Content-Type',  'text/xml; utf-8');    
        print($tei->asXML());
        drupal_exit();
    }
}