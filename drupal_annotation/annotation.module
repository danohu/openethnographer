<?php 

/**
 * Implements hook_permission().
 */
function annotation_permission() {
  return array(
    'administer annotation types' => array(
      'title' => t('Administer annotation types'),
      'description' => t('Allows users to administer annotation types.'),
      'restrict access' => TRUE,
    ),
    'administer annotations' => array(
      'title' => t('Administer annotations'),
      'description' => t('Allows users to administer annotations.'),
      'restrict access' => TRUE,
    ),
    'create annotations' => array(
      'title' => t('Create annotations'),
      'description' => t('Allows users to annotation tasks.'),
      'restrict access' => TRUE,
    ),
    'view annotations' => array(
      'title' => t('View annotations'),
      'description' => t('Allows users to view annotations.'),
      'restrict access' => TRUE,
    ),
    'edit any annotations' => array(
      'title' => t('Edit any annotations'),
      'description' => t('Allows users to edit any annotations.'),
      'restrict access' => TRUE,
    ),
    'edit own annotations' => array(
      'title' => t('Edit own annotation'),
      'description' => t('Allows users to edit own annotations.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function annotation_entity_info() {
  $info = array(
    'annotation' => array(
      'label' => t('Annotation'),
      'plural label' => t('Annotations'),
      'description' => t('An entity type used by the Annotator.'),
      //'entity class' => 'AnnotationClassRevision',
      'controller class' => 'AnnotationAPIController',
      'views controller class' => 'EntityDefaultViewsController',
      'base table' => 'annotation',
      // 'revision table' => 'annotation_revision',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'id',
        'bundle' => 'type',
        'language' => 'language',
        // 'revision' => 'revision_id',
      ),
      'label callback' => 'annotation_label',
      'uri callback' => 'annotation_uri',
      'bundles' => array(
        'annotator' => array(
          'label' => 'Annotator',
          'description' => 'Default Annotation type, use Annotator (need install).',
          'admin' => array(
            'path' => 'admin/structure/annotation/manage/%annotation_type',
            'real path' => 'admin/structure/annotation/manage/annotator',
            'bundle argument' => 4,
            'access arguments' => array('administer annotation'),
          ),
          'custom' => FALSE,
          'plugin' => 'annotator',
        )
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Default'),
          'custom settings' => FALSE,
        ),
      ),
      'module' => 'annotation',
      'static cache' => TRUE,
    ),
  );

  // Support entity cache module.
  if (module_exists('entitycache')) {
    $info['annotation']['field cache'] = FALSE;
    $info['annotation']['entity cache'] = TRUE;
  }

  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function annotation_entity_property_info_alter(&$info) {
  $properties = &$info['annotation']['properties'];
  $properties['created'] = array(
    'label' => t('Date created'),
    'type' => 'date',
    'description' => t('The date the annotation was created.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer annotations',
    'schema field' => 'created',
  );
  $properties['updated'] = array(
    'label' => t('Date updated'),
    'type' => 'date',
    'schema field' => 'updated',
    'description' => t('The date the annotation was last updated.'),
  );
  $properties['user'] = array(
    'label' => t('Author'),
    'type' => 'user',
    'description' => t('The author of the annotation.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer annotations',
    'required' => TRUE,
    'schema field' => 'uid',
  );
}

/**
 * Implements hook_menu().
 */
function annotation_menu() {
  $items = array();

  // Admin menu items.

  // Admin menu item for the page to list annotations.
  $items['admin/content/annotation'] = array(
    'title' => 'Annotations',
    'description' => 'Manage Annotations',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('annotation_admin_content'),
    'access arguments' => array('access content overview'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'annotation.admin.inc',
  );
  $items['admin/content/annotation/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  // Admin menu item for the page to list annotation types.
  $items['admin/structure/annotation'] = array(
    'title' => 'Annotation',
    'description' => 'Manage annotaions.',
    'page callback' => 'annotation_admin_types',
    'access arguments' => array('administer content types'),
    'file' => 'annotation.admin.inc',
  );
  $items['admin/structure/annotation/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Admin menu item for the page to add a new annotation type. Work in progress, so disabled in the release so far.
  /*
  $items['admin/structure/annotation/add'] = array(
    'title' => 'Add annotation type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('annotation_type_form'),
    'access arguments' => array('administer content types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'annotation.admin.inc',
  );
  */

  // Admin menu items to edit annotation types, one for each annotation type.
  $entity_info = entity_get_info('annotation');
  foreach ($entity_info['bundles'] as $annotation_type => $bundle_info) {
    if (isset($bundle_info['admin'])) {
      // Get the base path and access.
      $path = $bundle_info['admin']['path'];
      $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
      $access += array(
        'access callback' => 'user_access',
        'access arguments' => array('administer annotations'),
      );

      // The annotation type must be passed to the page callbacks. It might be
      // configured as a wildcard (multiple annotation types sharing the same menu
      // router path).
      $annotation_type_argument = isset($bundle_info['admin']['bundle argument']) ? $bundle_info['admin']['bundle argument'] : $annotation_type;
      $items[$path] = array(
        'title' => 'Edit annotation type',
        //'title callback' => 'annotation_type_get_name',
        //'title arguments' => array(4),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('annotation_type_form', $annotation_type_argument),
        'file' => 'annotation.admin.inc',
      ) + $access;

      // Add the 'annotation type settings' tab.
      $items["$path/edit"] = array(
        'title' => 'Edit',
        'type' => MENU_DEFAULT_LOCAL_TASK,
      );
    }
  }

  // Frontend menu items.

  // Parametric frontend menu item to view a single annotation.
  $items['annotation/%entity_object'] = array(
    'load arguments' => array('annotation'),
    'title callback' => 'entity_label',
    'title arguments' => array('annotation', 1),
    'page callback' => 'annotation_view_page',
    'page arguments' => array(1, 'annotation'),
    'access callback' => 'annotation_access',
    'access arguments' => array('view', 1),
    'file' => 'annotation.pages.inc',
  );

  // Parametric frontend menu item to delete a single annotation.
  $items['annotation/%entity_object/delete'] = array(
    'load arguments' => array('annotation'),
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments'  => array('annotation_delete_form', 1),
    'access callback' => 'annotation_access',
    'access arguments' => array('delete', 1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'annotation.pages.inc',
  );

  // Frontend menu item for a page to export annotations.
  $items['annotation/export'] = array(
    'title' => 'Export my annotations',
    'page callback' => 'annotation_export_submit',
    'page arguments' => array(2),
    'access arguments' => array('create annotations'), // Since users who may annotate may also view and export their work.
  );

  // Menu items for the annotation API.

  // Index; API endpoint
  $items['annotation/api'] = array(
    'page callback' => 'annotation_api',
    'access callback' => /*'annotation_method_access'*/TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );
  // Create; API endpoint to create annotations
  $items['annotation/api/annotations'] = array(
    'page callback' => 'annotation_api_endpoint',
    'access callback' => /*'annotation_method_access'*/TRUE,
    'access arguments' => array('', 'annotation', NULL),
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );
  // View / Edit / Delete; API endpoint to update an existing annotation
  $items['annotation/api/annotations/%'] = array(
    'page callback' => 'annotation_api_endpoint',
    'page arguments' => array(3),
    'access callback' => /*'annotation_method_access'*/TRUE,
    'access arguments' => array('', 'annotation', 3),
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );
  // Search; API endpoint to searh in existing annotations
  $items['annotation/api/search'] = array(
    'page callback' => 'annotation_api_search',
//    'access callback' => 'annotation_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'annotation.store.inc',
  );

  return $items;
}

/**
 * Access callback.
 */
function annotation_access($op, $entity, $account = NULL, $entity_type = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  if ($account->uid == 1) {
    return TRUE;
  }

  switch ($op) {
    case 'create':
      return user_access('administer annotations', $account)
          || user_access('create annotations', $account);
    case 'view':
      return user_access('administer annotations', $account)
          || user_access('view any annotations', $account)
          || ($entity->uid == $account->uid);
    case 'edit':
      return user_access('administer annotations', $account)
          || user_access('edit any annotations', $account)
          || (user_access('edit own annotations', $account) && ($entity->uid == $account->uid));
    case 'delete':
      return user_access('administer annotations', $account)
          || user_access('edit any annotations', $account)
          || (user_access('edit own annotations', $account) && ($entity->uid == $account->uid));
  }
}

/**
 * Method dependent access callback
 * @see annotation_api_endpoint()
 */
function annotation_entity_method_access($op, $entity_type, $entity = NULL, $account = NULL) {
  $method = $_SERVER['REQUEST_METHOD'];

  switch ($method) {
    case 'GET':
      if (isset($entity) && is_numeric($id)) {
        annotation_api_read($id);
        // entity_access('view', $entity_type, $entity = NULL, $account = NULL);
      }
      else {
        annotation_api_index();
        // entity_access('view', $entity_type, $entity = NULL, $account = NULL);
      }
      break;
    case 'POST':
      annotation_api_create();
      // entity_access('create', $entity_type, $entity = NULL, $account = NULL);
      break;
    case 'PUT':
      annotation_api_update($id);
      break;
    case 'DELETE':
      annotation_api_destroy($id);
      break;
  }
}

/**
 * Menu argument loader: loads a annotation type by string.
 *
 * @param $name
 *   The machine-readable name of a node type to load, where '_' is replaced
 *   with '-'.
 *
 * @return
 *   A node type object or FALSE if $name does not exist.
 */
function annotation_type_load($name) {
  $annotation_entity = entity_get_info('annotation');
  $bundle = $annotation_entity['bundles'][$name];
  $bundle['type'] = $name;
  //$type = ctools_export_crud_load('file_type', $name);
  return (object)$bundle;
}

function annotation_type_get_names() {
  $names = &drupal_static(__FUNCTION__);

  if (!isset($names)) {
    $info = entity_get_info('annotation');
    foreach ($info['bundles'] as $bundle => $bundle_info) {
      $names[$bundle] = $bundle_info['label'];
    }
  }

  return $names;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function annotation_ctools_plugin_directory($module, $plugin) {
  if ($module == 'annotator') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function annotation_ctools_plugin_type() {
  return array(
    'annotator' => array(
      'cache' => FALSE,
    ),
  );
}


//
// Section: Exporting to RQDA
//

/**
 * Sanitize a string for usage in a filename.
 *
 * Code taken over from the Drupal transliteration module's transliteration_clean_filename() since we 
 * do not want a dependency from a module just because of this one function.
 *
 * @see http://drupalcontrib.org/api/drupal/contributions!transliteration!transliteration.module/function/transliteration_clean_filename/7
 */
function _clean_filename($filename) {
  // Replace whitespace.
  $filename = str_replace(' ', '_', $filename);
  // Remove remaining unsafe characters.
  $filename = preg_replace('![^0-9A-Za-z_.-]!', '', $filename);
  // Remove multiple consecutive non-alphabetical characters.
  $filename = preg_replace('/(_)_+|(\.)\.+|(-)-+/', '\\1\\2\\3', $filename);
  // Force lowercase to prevent issues on case-insensitive file systems.
  if (variable_get('transliteration_file_lowercase', TRUE)) {
    $filename = strtolower($filename);
  }
  return $filename;
}

/**
 * Menu callback that collects the export form options and initiates the export of annotations.
 */
function annotation_export_submit() {  
  global $user;

  // Generate the filename to export to. Must be unique, as it will be saved in a tmp directory.
  $export_filename = "Codings_by_" . $user->name . '_' . date('Y-m-d_H-i-s') . ".rqda";
  $export_filename = _clean_filename($export_filename);

  $export_pathname = file_directory_temp() . "/$export_filename";

  $success = annotation_export_rqda($user->uid, $export_pathname);

  // Offer the exported file to the user for download.
  if ($success === TRUE) {
    drupal_add_http_header('Content-Type', 'application/x-sqlite3');
    drupal_add_http_header('Content-disposition', "attachment; filename=$export_filename");
    readfile($export_pathname);
    drupal_exit();
  }
  // Or log an error message.
  else {
    $message = 'Failed to export your annotations.';
    drupal_set_message($message, 'error');
    watchdog('annotation', $messsage, array(), WATCHDOG_ERROR);
  }
}

/**
 * Obtain the node IDs of all nodes annotated by the given user.
 */
function annotation_nids($uid) {
  $query = db_select('annotation', 'anno');
  $result = $query
    ->distinct()
    ->fields('anno', array('nid'))
    ->condition('uid', $uid, '=')
    ->isNotNull('tid')
    ->orderBy('nid')
    ->execute()
    ->fetchCol(0);
  return $result;
}

/**
 * Obtain the tag IDs of all annotation tags (used or unused) which are owned by the specified user.
 *
 * TODO Filter the query by $uid once the author field is added to the vocabulary.
 */
function annotation_tids($uid) {
  $vocabulary = taxonomy_vocabulary_machine_name_load('openethnographer');
  
  $query = db_select('taxonomy_term_data', 'terms');
  $result = $query
    ->fields('terms', array('tid'))
    ->condition('vid', $vocabulary->vid, '=')
    ->orderBy('tid')
    ->execute()
    ->fetchCol(0);
  return $result;
}

/**
 * Obtain the IDs of all annotations which are created by the specified user.
 */
function annotation_ids($uid){
  $query = db_select('annotation', 'anno');
  $result = $query
    ->fields('anno', array('id'))
    ->condition('uid', $uid, '=')
    ->orderBy('nid') // So when traversing the result, nodes are only reloaded when needed.
    ->execute()
    ->fetchCol(0);
  // TODO Just in case, filter out those using tags not owned by the user, by calling annotation_tids($uid).

  return $result;
}

/**
 * Create the RQDA database schema in the given SQLite3 database.
 *
 * When updates of RQDA are released, the schema definition can be updated by creating and 
 * saving project in RQDA, then exporting its schema with for example sqliteman.
 */
function annotation_create_rqda_schema($db) {
  $db->exec('PRAGMA foreign_keys=OFF');
  $db->exec('BEGIN TRANSACTION');

  $db->exec('CREATE TABLE source ( 
    name text, id integer, file text, memo text, owner text, date text, dateM text, status integer )');
  $db->exec('CREATE TABLE freecode ( 
    name text, memo text, owner text, date text, dateM text, id integer, status integer, color text )');
  $db->exec('CREATE TABLE treecode ( 
    cid integer, catid integer, date text, dateM text, memo text, status integer, owner text )');
  $db->exec('CREATE TABLE treefile ( 
    fid integer, catid integer, date text, dateM text, memo text, status integer, owner text )');
  $db->exec('CREATE TABLE filecat (
    name text,fid integer, catid integer, owner text, date text, dateM text, memo text, status integer )');
  $db->exec('CREATE TABLE codecat ( 
    name text, cid integer, catid integer, owner text, date text, dateM text, memo text, status integer)');
  $db->exec('CREATE TABLE coding ( 
    cid integer, fid integer, seltext text, selfirst real, selend real, status integer, owner text, date text, memo text )');
  $db->exec('CREATE TABLE coding2 (
    cid integer, fid integer, seltext text, selfirst real, selend real, status integer, owner text, date text, memo text )');
  $db->exec('CREATE TABLE project (
    databaseversion text, date text, dateM text, memo text,about text, imageDir text )');
  $db->exec('CREATE TABLE cases (
    name text, memo text, owner text, date text,dateM text, id integer, status integer )');
  $db->exec('CREATE TABLE caselinkage ( 
    caseid integer, fid integer, selfirst real, selend real, status integer, owner text, date text, memo text )');
  $db->exec('CREATE TABLE attributes (
    name text, status integer, date text, dateM text, owner text,memo text, class text )');
  $db->exec('CREATE TABLE caseAttr (
    variable text, value text, caseID integer, date text, dateM text, owner text, status integer )');
  $db->exec('CREATE TABLE fileAttr ( 
    variable text, value text, fileID integer, date text, dateM text, owner text, status integer )');
  $db->exec('CREATE TABLE journal ( 
    name text, journal text, date text, dateM text, owner text, status integer )');
  $db->exec('CREATE TABLE annotation (
    fid integer, position integer, annotation text, owner text, date text, dateM text, status integer )');
  $db->exec('CREATE TABLE image ( 
    name text, id integer, date text, dateM text, owner text, status integer)');
  $db->exec('CREATE TABLE imageCoding ( 
    cid integer, iid integer, x1 integer, y1 integer, x2 integer, y2 integer, memo text, date text, dateM text, owner text,status integer)');

  
  $db->exec("INSERT INTO project VALUES ( 
    '0.2.2', '" . date('Y-m-d H:i:s') . "', NULL, '', 
    'Database created by Open Ethnographer (https://github.com/edgeryders/openethnographer)', NULL )");
  $db->exec('COMMIT TRANSACTION');
}

/**
 * Convert the given DOM node to plain text, not considering its child nodes.
 * 
 * Every XML_TEXT_NODE will be converted to its text, br to a newline, a block node (except container nodes like ul, ol) 
 * to an empty line, and everything else to the empty string.
 */
function dom_element_text($node) {
  $blocklevel_tags = array('h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'p', 'li', 'dt', 'dd', 'th', 'tr');

  if ($node->nodeType === XML_TEXT_NODE) {
    return $node->wholeText;
  }
  elseif ($node->nodeType === XML_ELEMENT_NODE and $node->tagName == 'br') {
    return PHP_EOL;
  }
  elseif ($node->nodeType === XML_ELEMENT_NODE and in_array($node->tagName, $blocklevel_tags )) {
    return PHP_EOL . PHP_EOL;
  }
}

/**
 * Determine the character index that the first character of the specified tag has in a plaintext version of the given DOM document.
 *
 * @param dom DOMDocument
 * @param xpath String A string with an XPath query that specifies exactly one DOM element. If the query result is multiple elements, 
 *   only the first one will be used.
 * @return integer
 */
function index_at_xpath($dom, $xpath_exp) {
  $text = '';

  $xpath = new DomXPath($dom);
  $target_list = $xpath->query($xpath_exp);
  if ($target_list->length >= 1) {
    $target = $target_list->item(0);
  }
  else {
    // TODO Log an error message.
    return FALSE;
  }

  // Traverse the DOM while converting it to plain text.
  $iter = new RecursiveIteratorIterator( new RecursiveDOMIterator($dom), RecursiveIteratorIterator::SELF_FIRST );
  foreach($iter as $node) {
    if ($node->isSameNode($target)) {
      return strlen($text); // Length of plain text conversion so far equals character index of first character in $target.
    }
    else {
      $text .= dom_element_text($node);
    }
  }
}


define('ANNOTATION_START', 0);
define('ANNOTATION_END', 1);

/**
 * Convert a JSON encoded annotation range from XPath to start and end character indices for plain text.
 *
 * Currently, only the first text range is decoded and returned. However, multiple ranges cannot be used by any client of the 
 * Drupal annotation plugin so far (means, Annotator JS, Open Ethnographer).
 *
 * @param $position Either ANNOTATION_START or ANNOTATION_END, depending on if you want the start or end character index of the 
 *   given annotation's range calculated.
 * @return mixed The required character index as an integer, or FALSE in error cases (incl. when giving an unknown value as 
 *   the position parameter).
 */
function annotation_index($node, $anno, $position){
  // Cache a DOM representation of the body field into the node.
  if (!isset($node->bodyDOM) or get_class($node->bodyDOM)!='DOMDocument') {
    $node->bodyDOM = new DOMDocument;
    // Enclose the body HTML because DOMDocument expects exactly one outer tag (see http://stackoverflow.com/a/12806767/1270008 ).
    $enclosed_body = '<div>' . field_get_items('node', $node, 'body')[0]['value'] . '</div>';
    $success = $node->bodyDOM->loadHTML($enclosed_body);
    // Bad success also happens for warnings (already generating their own log entries), so proceed if meaningful.
    if ($success === FALSE and $node->bodyDOM->childNodes->length === 0) {
      $message = "Could not create DOM object for node {$node->nid}.";
      drupal_set_message($message, 'error');
      watchdog('annotation', $message, array(), WATCHDOG_ERROR);
      unset($node->bodyDOM);
      return FALSE;
    }
  }

  $range = $anno->ranges[0];
  // Structure of $range: array('start' => 'XPath value', 'startOffset' => int, 'end' => 'XPath value', 'endOffset' => int).
  // Assumption: character indexes indicate the first character that belongs, and the first that no longer belongs to the range.

  if ($position == ANNOTATION_START) {
    return index_at_xpath($node->bodyDOM, $range['start']) + $range['startOffset'];
  }
  elseif ($position == ANNOTATION_END) {
    return index_at_xpath($node->bodyDOM, $range['end']) + $range['endOffset'];
  }
  else {
    return FALSE;
  }
}

/**
 * Export all annotations of the specified user to the specified file.
 *
 * @return TRUE on success, FALSE in error cases.
 *
 * @see RQDA database schema docs: http://www.inside-r.org/packages/cran/RQDA/docs/RQDATables
 */
function annotation_export_rqda($uid, $filename) {
  global $base_url; 

  watchdog('annotation', 'Starting to export annotations.');
  $user = user_load($uid);

  // Initialze the target file with the database schema.
  $db = new SQLite3($filename);
  annotation_create_rqda_schema($db);

  // Variable to collect the length of metadata prepended to content.
  $prefix_length = array();

  // Collect all nodes which the specified user has annotated.
  $nids = annotation_nids($uid);

  // Export all nodes which the specified user has annotated.
  // Content goes into RQDA "files" (table "source").
  $db->exec('BEGIN TRANSACTION');  // Avoids implicit transaction (disk io ops!) after every INSERT below.
  foreach ($nids as $nid) {
    $node = node_load($nid);

    // TODO Check that the user has (still) view permissions for this content.
    watchdog('annotation', "Debug: Exporting node with Drupal nid {$node->nid}.");

    // TODO Convert the node body to plain text.
    $node_text = '';
    $node_dom = new DOMDocument;
    // Enclose the body HTML, as DOMDocument needs exactly one outer tag (see http://stackoverflow.com/a/12806767/1270008 ).
    $enclosed_body = '<div>' . field_get_items('node', $node, 'body')[0]['value'] . '</div>';
    $success = $node_dom->loadHTML($enclosed_body);
    // Bad success also happens for warnings (already generating their own log entries), so proceed if meaningful.
    if ($success === FALSE and $node_dom->childNodes->length === 0) {
      $message = "Could not create DOM object for node {$node->nid}.";
      drupal_set_message($message, 'error');
      watchdog('annotation', $message, array(), WATCHDOG_ERROR);
      return FALSE;
    }
    $iter = new RecursiveIteratorIterator( new RecursiveDOMIterator($node_dom), RecursiveIteratorIterator::SELF_FIRST );
    foreach($iter as $dom_element) {
      $node_text .= dom_element_text($dom_element);
    }
    $node_preface = "Content Title: {$node->title}" . PHP_EOL .
      "Content ID: node $nid" . PHP_EOL . 
      "Content Link: " . url("node/$nid", array('absolute' => TRUE)) . PHP_EOL . 
      "Author Name: " . user_load($node->uid)->name . PHP_EOL .
      "Author Link: " . url("user/{$node->uid}", array('absolute' => TRUE)) . PHP_EOL . PHP_EOL;

    $prefix_length[$nid] = strlen($node_preface);
    $node_text = $node_preface . $node_text;
    $node_text = str_replace("'", "''", $node_text); // Escape quotes for SQLite.

    // TODO Test for the case that the core title field is used (called "field_title"), rather than the Field API's replacement "title_field".
    $node_title = field_get_items('node', $node, 'title_field')[0]['value'];
    $node_title = str_replace("'", "''", $node_title); // Escape quotes for SQLite.

    // Write the SQLite record for this ethnographic "file".
    // Column "status = 1" means standard status, "status = 0" means temp deleted.
    // TODO Also export into the "date" column.
    $db->exec("INSERT INTO source (name, id, file, owner, status) VALUES ( 
      '$node_title', '{$node->nid}', '$node_text', '{$user->name}', '1' )");
  }
  $db->exec('COMMIT TRANSACTION');


  // Collect all annotation tags owned by the specified user (used or unused).
  $tids = annotation_tids($uid);

  // Export all annotation tags created by the specified user.
  $db->exec('BEGIN TRANSACTION');  // Avoids implicit transaction (disk io ops!) after every INSERT below.
  foreach ($tids as $tid) {
    $tag = taxonomy_term_load($tid);
    watchdog('annotation', "Debug: Exporting tag with Drupal tid {$tag->tid}.");

    $tag_title = str_replace("'", "''", $tag->title); // Escape quotes for SQLite.
    $tag_description = str_replace("'", "''", $tag->description); // Escape quotes for SQLite.

    // Write the SQLite record for this ethnographic "code".
    // Column "status = 1" means standard status, "status = 0" means temp deleted.
    $db->exec("INSERT INTO freecode (name, memo, owner, id, status) VALUES ( 
      '$tag_title', '$tag_description', '{$user->name}', '{$tag->tid}', '1' )");
  }
  $db->exec('COMMIT TRANSACTION');


  // Collect all annotations created by the specified user.
  $aids = annotation_ids($uid);

  // Export all annotations created by the specified user.
  $annotations = entity_load_multiple_by_name('annotation', $aids);
  $db->exec('BEGIN TRANSACTION');  // Avoids implicit transaction (disk io ops!) after every INSERT below.
  foreach ($annotations as $aid => $anno) {
    // Reload the node if the new annotation belongs to a different one.
    // $annotations is ordered by node affiliation, see annotation_ids(). So every annotated node is loaded only once.
    if ($anno->nid != $node->nid) {
      $node = node_load($anno->nid);
    }

    $anno_start_index = $prefix_length[$node->nid] + annotation_index($node, $anno, ANNOTATION_START);
    $anno_end_index   = $prefix_length[$node->nid] + annotation_index($node, $anno, ANNOTATION_END);

    $anno_quote = str_replace("'", "''", $anno->quote); // Escape quotes for SQLite.

    // Write the SQLite record for this ethnographic "coding".
    // Column "status = 1" means standard status, "status = 0" means deleted.
    $db->exec("INSERT INTO coding (cid, fid, seltext, selfirst, selend, status, owner, date, memo) VALUES (
      '{$anno->tid}', '{$anno->nid}', '$anno_quote', '$anno_start_index', '$anno_end_index', 
      1, '{$user->name}', '{$anno->updated}', NULL )");
    watchdog('annotation', "Exported annotation {$anno->id}.");
  }
  $db->exec('COMMIT TRANSACTION');

  watchdog('annotation', 'Finished exporting annotations.');

  return TRUE;
}

